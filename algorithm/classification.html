<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法分类 | 进阶</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/myBlog/cc.png">
    <meta name="description" content="学习笔记">
    <link rel="preload" href="/myBlog/assets/css/0.styles.8a57e611.css" as="style"><link rel="preload" href="/myBlog/assets/js/app.e2a5d604.js" as="script"><link rel="preload" href="/myBlog/assets/js/3.8a7523f6.js" as="script"><link rel="preload" href="/myBlog/assets/js/1.015dc369.js" as="script"><link rel="preload" href="/myBlog/assets/js/22.aff7fda6.js" as="script"><link rel="prefetch" href="/myBlog/assets/js/10.7b1b0431.js"><link rel="prefetch" href="/myBlog/assets/js/11.d26e9a40.js"><link rel="prefetch" href="/myBlog/assets/js/12.ad86edaf.js"><link rel="prefetch" href="/myBlog/assets/js/13.b6ddd56e.js"><link rel="prefetch" href="/myBlog/assets/js/14.9325d2fa.js"><link rel="prefetch" href="/myBlog/assets/js/15.e91821a3.js"><link rel="prefetch" href="/myBlog/assets/js/16.aae430a7.js"><link rel="prefetch" href="/myBlog/assets/js/17.2293bccf.js"><link rel="prefetch" href="/myBlog/assets/js/18.3a2d69c2.js"><link rel="prefetch" href="/myBlog/assets/js/19.21fb125c.js"><link rel="prefetch" href="/myBlog/assets/js/20.65b7b522.js"><link rel="prefetch" href="/myBlog/assets/js/21.28eaba47.js"><link rel="prefetch" href="/myBlog/assets/js/23.c602883e.js"><link rel="prefetch" href="/myBlog/assets/js/24.594933e4.js"><link rel="prefetch" href="/myBlog/assets/js/25.55bdb4c3.js"><link rel="prefetch" href="/myBlog/assets/js/26.e4b56c42.js"><link rel="prefetch" href="/myBlog/assets/js/27.7723c24c.js"><link rel="prefetch" href="/myBlog/assets/js/28.32f098cb.js"><link rel="prefetch" href="/myBlog/assets/js/29.60da25c4.js"><link rel="prefetch" href="/myBlog/assets/js/30.37b3a9da.js"><link rel="prefetch" href="/myBlog/assets/js/31.323fd96d.js"><link rel="prefetch" href="/myBlog/assets/js/32.1ab6f4c6.js"><link rel="prefetch" href="/myBlog/assets/js/33.8d544844.js"><link rel="prefetch" href="/myBlog/assets/js/34.4138dd44.js"><link rel="prefetch" href="/myBlog/assets/js/35.11e392dd.js"><link rel="prefetch" href="/myBlog/assets/js/36.c46ef8b9.js"><link rel="prefetch" href="/myBlog/assets/js/37.75e4735d.js"><link rel="prefetch" href="/myBlog/assets/js/38.072d7b78.js"><link rel="prefetch" href="/myBlog/assets/js/39.995eb93d.js"><link rel="prefetch" href="/myBlog/assets/js/4.44cbef6d.js"><link rel="prefetch" href="/myBlog/assets/js/40.24090d6b.js"><link rel="prefetch" href="/myBlog/assets/js/41.adbf0a9c.js"><link rel="prefetch" href="/myBlog/assets/js/42.97dbaef6.js"><link rel="prefetch" href="/myBlog/assets/js/43.7ccae9bb.js"><link rel="prefetch" href="/myBlog/assets/js/44.4aded0ce.js"><link rel="prefetch" href="/myBlog/assets/js/45.d0d85797.js"><link rel="prefetch" href="/myBlog/assets/js/46.be569ca1.js"><link rel="prefetch" href="/myBlog/assets/js/47.8f73e39d.js"><link rel="prefetch" href="/myBlog/assets/js/48.e8a54dca.js"><link rel="prefetch" href="/myBlog/assets/js/49.8f61a5f4.js"><link rel="prefetch" href="/myBlog/assets/js/5.12015b3b.js"><link rel="prefetch" href="/myBlog/assets/js/50.7209d829.js"><link rel="prefetch" href="/myBlog/assets/js/51.ab4ee2db.js"><link rel="prefetch" href="/myBlog/assets/js/52.c3bc0832.js"><link rel="prefetch" href="/myBlog/assets/js/53.d5a56b90.js"><link rel="prefetch" href="/myBlog/assets/js/54.f65f0712.js"><link rel="prefetch" href="/myBlog/assets/js/55.160b9312.js"><link rel="prefetch" href="/myBlog/assets/js/56.46a7734a.js"><link rel="prefetch" href="/myBlog/assets/js/57.99a2b252.js"><link rel="prefetch" href="/myBlog/assets/js/58.a316dab3.js"><link rel="prefetch" href="/myBlog/assets/js/59.4bf8ed70.js"><link rel="prefetch" href="/myBlog/assets/js/6.4d13203e.js"><link rel="prefetch" href="/myBlog/assets/js/60.1e83d145.js"><link rel="prefetch" href="/myBlog/assets/js/61.9fa35932.js"><link rel="prefetch" href="/myBlog/assets/js/62.2e3408ea.js"><link rel="prefetch" href="/myBlog/assets/js/7.77c77d24.js"><link rel="prefetch" href="/myBlog/assets/js/8.37d401c0.js"><link rel="prefetch" href="/myBlog/assets/js/9.711da3e2.js">
    <link rel="stylesheet" href="/myBlog/assets/css/0.styles.8a57e611.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-9f1e2f90><div data-v-9f1e2f90><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-9f1e2f90 data-v-9f1e2f90><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76>进阶</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>R-Z</span>
            
          <!---->
          2021
        </a></span></div></div> <div class="hide" data-v-9f1e2f90><header class="navbar" data-v-9f1e2f90><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/myBlog/" class="home-link router-link-active"><img src="/myBlog/cc.png" alt="进阶" class="logo"> <span class="site-name">进阶</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/myBlog/" class="nav-link"><i class="iconfont undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/categories/布局/" class="nav-link"><i class="iconfont undefined"></i>
  布局
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/网络/" class="nav-link"><i class="iconfont undefined"></i>
  网络
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/编程/" class="nav-link"><i class="iconfont undefined"></i>
  编程
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/tools/" class="nav-link"><i class="iconfont undefined"></i>
  tools
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/智能/" class="nav-link"><i class="iconfont undefined"></i>
  智能
</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/myBlog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/myBlog/frontend/" class="nav-link"><i class="iconfont undefined"></i>
  前端知识
</a></div><div class="nav-item"><a href="/myBlog/algorithm/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  算法
</a></div><div class="nav-item"><a href="/myBlog/project/" class="nav-link"><i class="iconfont undefined"></i>
  项目
</a></div><div class="nav-item"><a href="/myBlog/notes/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></div><div class="nav-item"><a href="/myBlog/blog/" class="nav-link"><i class="iconfont undefined"></i>
  文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      Languages
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/language/chinese.html" class="nav-link"><i class="iconfont undefined"></i>
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/language/English.html" class="nav-link"><i class="iconfont undefined"></i>
  English
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-9f1e2f90></div> <aside class="sidebar" data-v-9f1e2f90><div class="personal-info-wrapper" data-v-3eba7259 data-v-9f1e2f90><!----> <h3 class="name" data-v-3eba7259>
    R-Z
  </h3> <div class="num" data-v-3eba7259><div data-v-3eba7259><h3 data-v-3eba7259>26</h3> <h6 data-v-3eba7259>Article</h6></div> <div data-v-3eba7259><h3 data-v-3eba7259>13</h3> <h6 data-v-3eba7259>Tag</h6></div></div> <hr data-v-3eba7259></div> <nav class="nav-links"><div class="nav-item"><a href="/myBlog/" class="nav-link"><i class="iconfont undefined"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      Category
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/categories/布局/" class="nav-link"><i class="iconfont undefined"></i>
  布局
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/网络/" class="nav-link"><i class="iconfont undefined"></i>
  网络
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/编程/" class="nav-link"><i class="iconfont undefined"></i>
  编程
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/tools/" class="nav-link"><i class="iconfont undefined"></i>
  tools
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/工具/" class="nav-link"><i class="iconfont undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/面试/" class="nav-link"><i class="iconfont undefined"></i>
  面试
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/categories/智能/" class="nav-link"><i class="iconfont undefined"></i>
  智能
</a></li></ul></div></div><div class="nav-item"><a href="/myBlog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div><div class="nav-item"><a href="/myBlog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  TimeLine
</a></div><div class="nav-item"><a href="/myBlog/frontend/" class="nav-link"><i class="iconfont undefined"></i>
  前端知识
</a></div><div class="nav-item"><a href="/myBlog/algorithm/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  算法
</a></div><div class="nav-item"><a href="/myBlog/project/" class="nav-link"><i class="iconfont undefined"></i>
  项目
</a></div><div class="nav-item"><a href="/myBlog/notes/" class="nav-link"><i class="iconfont undefined"></i>
  笔记
</a></div><div class="nav-item"><a href="/myBlog/blog/" class="nav-link"><i class="iconfont undefined"></i>
  文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      Languages
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/myBlog/language/chinese.html" class="nav-link"><i class="iconfont undefined"></i>
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/myBlog/language/English.html" class="nav-link"><i class="iconfont undefined"></i>
  English
</a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/myBlog/algorithm/" aria-current="page" class="sidebar-link">笔记</a></li><li><a href="/myBlog/algorithm/offer.html" class="sidebar-link">剑指offer题解</a></li><li><a href="/myBlog/algorithm/interview.html" class="sidebar-link">常考算法</a></li><li><a href="/myBlog/algorithm/leetcode.html" class="sidebar-link">leetcode题解</a></li><li><a href="/myBlog/algorithm/classification.html" aria-current="page" class="active sidebar-link">算法分类</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-58d5ab76 data-v-9f1e2f90><h3 class="title" style="display:none;" data-v-58d5ab76 data-v-58d5ab76></h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><input type="password" value="" data-v-58d5ab76> <span data-v-58d5ab76>Konck! Knock!</span> <button data-v-58d5ab76>OK</button></label> <div class="footer" style="display:none;" data-v-58d5ab76 data-v-58d5ab76><span data-v-58d5ab76><i class="iconfont reco-theme" data-v-58d5ab76></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-58d5ab76>vuePress-theme-reco</a></span> <span data-v-58d5ab76><i class="iconfont reco-copyright" data-v-58d5ab76></i> <a data-v-58d5ab76><span data-v-58d5ab76>R-Z</span>
            
          <!---->
          2021
        </a></span></div></div> <div data-v-9f1e2f90><main class="page"><div class="page-title" style="display:none;"><h1 class="title">算法分类</h1> <div data-v-42458482><i class="iconfont reco-account" data-v-42458482><span data-v-42458482>R-Z</span></i> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="算法分类"><a href="#算法分类" class="header-anchor">#</a> 算法分类</h1> <h2 id="排序"><a href="#排序" class="header-anchor">#</a> 排序</h2> <h3 id="_1-冒泡排序"><a href="#_1-冒泡排序" class="header-anchor">#</a> 1. 冒泡排序</h3> <p>说明：冒泡排序属于交换排序，在双层循环中实现，每一次内层循环结束，都会将一个数字交换到最终的位置，为了交换的完整性，内层循环从后向左进行比较，以下算法均为从小到大排序。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// swap函数  </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>  
<span class="token comment">// 冒泡排序  </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">BubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> len <span class="token operator">=</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  
    <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 冒泡排序优化，标志位  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> flag<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// j不能等于i，否则j-1会越界  </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment">// 若发生交换，则进行下一次循环  </span>
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 若flag为false，则说明未发生交换，数组已经有序  </span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>注：冒泡排序算法时间复杂度O(n^2)，属于稳定排序，元素有序的情况较好，最坏全部逆序。</p> <h3 id="_2-直接插入排序"><a href="#_2-直接插入排序" class="header-anchor">#</a> 2. 直接插入排序</h3> <p>说明：插入排序就是将一个记录插入到已经排好序的有序表中，重点在于标记位的使用，进行临时存储数据与判断数组边界。<br>
思路：从第二位开始排序，将当前待排序的记录使用哨兵保存，若该记录小于前一位记录，则需要在循环中将前面的记录依次向后移动一个位置，直到遇到小于哨兵的记录出现，即为待排序记录的正确位置。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> s <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> s <span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token comment">// 使用j+1避免溢出问题  </span>
                num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            num<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>注：直接插入排序时间复杂度O(n^2)，属于稳定排序，性能优于冒泡，元素有序的情况较好，最坏全部逆序。</p> <h3 id="_3-希尔排序"><a href="#_3-希尔排序" class="header-anchor">#</a> 3. 希尔排序</h3> <p>说明：直接插入排序的改进，思想是首先设定增量把序列分为几个部分，然后进行直接插入排序，这样序列整体会更加有序,减少位置移动的次数。然后减小增量，继续进行插入排序，直至增量为1，全部元素有序。<br>
思路：增量初始化为数组长度，然后设置增量依次减少，判断条件如直接插入排序，但是其中要相应计算增量值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> increment <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>increment <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            increment <span class="token operator">=</span> increment <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> increment<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 注意是i++  </span>
                <span class="token keyword">int</span> s <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// nums[i]  </span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span>increment<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    <span class="token comment">// 这里j = i - increment，而不是等于i，如果等于i则nums[j-increment]会有溢出问题  </span>
                    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">-</span> increment<span class="token punctuation">;</span> j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> s<span class="token punctuation">;</span> j <span class="token operator">-=</span> increment<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// nums[j] &gt; s  </span>
                        nums<span class="token punctuation">[</span>j<span class="token operator">+</span>increment<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  
                    <span class="token punctuation">}</span>  
                    nums<span class="token punctuation">[</span>j<span class="token operator">+</span>increment<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
</code></pre></div><p>时间复杂度：O(n^2)，空间复杂度：O(1)<br>
属于稳定排序，元素有序的情况较好，最坏全部逆序。</p> <h3 id="_4-简单选择排序"><a href="#_4-简单选择排序" class="header-anchor">#</a> 4. 简单选择排序</h3> <p>说明：简单选择排序是从当前元素开始向后遍历，找到最小的元素与当前元素交换，直到遍历到最后一个元素。<br>
（1）设定min，存储最小元素下标<br>
（2）min初始值设为当前元素下标<br>
（3）遍历后面元素，根据大小改变min数值<br>
（4）若min发生变化，则交换min指向元素与当前元素</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">SelectSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> num<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            min <span class="token operator">=</span> i<span class="token punctuation">;</span>  
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> num<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> num<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>min <span class="token operator">!=</span> i<span class="token punctuation">)</span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> i<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
</code></pre></div><p>时间复杂度：O(n^2)，空间复杂度：O(1)，属于稳定排序</p> <h3 id="_5-堆排序"><a href="#_5-堆排序" class="header-anchor">#</a> 5. 堆排序</h3> <p>思想：堆排序是对给定数组构造大根堆（从小到大排序），然后将堆顶元素与最后一个元素依次交换，每交换一次堆长度减1，且将剩余元素继续调整成为一个大根堆，交换到最后就得到一个有序数组，属于选择排序。<br>
大根堆是一颗完全二叉树，因此大顶堆：<strong>arr[i] &gt;= arr[2<em>i+1] &amp;&amp; arr[i] &gt;= arr[2</em>i+2]</strong><br>
（1）自右向左，自底向上构造大根堆，将较大的元素依次调整上去<br>
（2）交换第一个元素与最后一个元素，然后除去最后一个元素，将剩余元素调整成为一个大顶堆，再次交换，直至最后一个元素</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 堆排序  </span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment">// 从第一个不是叶子结点的结点开始，右-&gt;左，下-&gt;上  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">adjustHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 要传入结点位置和数组长度  </span>
    <span class="token punctuation">}</span>  
    <span class="token comment">// 交换元素再调整  </span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">adjustHeap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为什么要传长度？因为此处长度在减小  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token comment">// 调整堆，根据传入的结点位置和长度  </span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment">// 保存要调整的结点值  </span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> k <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">// 当右结点大于左结点时，k设为右结点  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            k<span class="token operator">++</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 如果子结点大于该值，则将子结点调整上去  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 注：这里使不使用swap都可以，只要将子结点调整上去，因为i值在tmp中保存着  </span>
            i <span class="token operator">=</span> k<span class="token punctuation">;</span>  <span class="token comment">// 不要忘记！  </span>
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span>  <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token comment">// 及时跳出，节省时间，不跳出也不会出错      </span>
    <span class="token punctuation">}</span>  
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token comment">// 如果不使用swap要注意将tmp赋值给最终的i位置  </span>
<span class="token punctuation">}</span>  
</code></pre></div><p>时间复杂度：O(nlogn)，空间复杂度：O(1)，不稳定</p> <h3 id="_6-快速排序"><a href="#_6-快速排序" class="header-anchor">#</a> 6. 快速排序</h3> <p>思想：快速排序是将待排序序列根据某一基准，将大于该基准的数字移动到基准右边，小于该基准的数字移动到该基准左边。然后再对左边和右边的数字分别进行快速排序，属于递归调用，分治思想。<br>
（1）选取基准元素：一般选取中间的数或者头尾的数<br>
（2）选取两个指针，等于begin和end（注意end边界）<br>
（3）从后向前移动指针，直到找到小于基准元素的值，交换<br>
（4）从前向后移动指针，直到找到大于基准元素值，交换，完成一趟排序<br>
（5）分别对基准左边序列和右边序列进行快速排序</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment">// 首先加上判断，作为递归终止条件  </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span>  
        <span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span>begin<span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                j<span class="token operator">--</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                i<span class="token operator">++</span><span class="token punctuation">;</span>   <span class="token comment">// 注意啊啊啊  </span>
            <span class="token punctuation">}</span>  
            <span class="token comment">// 这里i &lt; j  </span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                i<span class="token operator">++</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  
                j<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment">// 注意啊啊啊  </span>
            <span class="token punctuation">}</span>          
        <span class="token punctuation">}</span>  
        <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>优化：三数取中+插排+聚集相等元素，而且在快排过程中不必使用swap()，因为我们只需要保留指针移动到的元素，基准值一直在key中保存，所以直接使用赋值操作，如以下代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> begin<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment">// 序列较小时，插排比快排效果更好  </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>  
        <span class="token punctuation">{</span>  
	        <span class="token class-name">InsertSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token keyword">else</span><span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>begin <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">int</span> i <span class="token operator">=</span> begin<span class="token punctuation">,</span> j <span class="token operator">=</span> end<span class="token punctuation">;</span>  
            <span class="token comment">// 三数取中，需另外定义函数  </span>
            <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token class-name">SelectMedianOfThree</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> end<span class="token punctuation">)</span> <span class="token punctuation">;</span>  
            <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    j<span class="token operator">--</span><span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 直接赋值  </span>
                    i<span class="token operator">++</span><span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
                <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    i<span class="token operator">++</span><span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>  
                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 直接赋值  </span>
                    j<span class="token operator">--</span><span class="token punctuation">;</span>  
                <span class="token punctuation">}</span>  
                <span class="token comment">// 一趟排序后key置于最终位置  </span>
                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> begin<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>   
<span class="token punctuation">}</span>  
</code></pre></div><p>最坏时间复杂度（全部逆序）：O(n^2)，平均时间复杂度：O(nlogn)<br>
不算系统栈空间的话，空间复杂度是O(1)，算的话是O(logn)，不稳定</p> <h3 id="_7-归并排序"><a href="#_7-归并排序" class="header-anchor">#</a> 7. 归并排序</h3> <p>思想：归并排序采用典型的分治思想，先分：自上而下，将序列从中间分成左右两组，再通过递归分别将两边继续划分，直至一组的元素为2个（或剩余一个），再治：自下而上，将划分好的元素进行排列，复制到原数组中，再向上将更多元素排列，直至整个序列有序。<br>
（1）划分：使用递归从上至下将序列划分<br>
（2）合并：相当于合并两个有序数组，使用双指针，新建一个tmp数组存储从小到大的元素（tmp数组在主函数中声明，节省空间），再将tmp数组对应元素拷贝到原数组中</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment">// 加上判断，递归终止条件  </span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// 从中间划分  </span>
        <span class="token class-name">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">MergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">Merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为什么要传mid，因为mid将序列划分为左右两个部分  </span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
<span class="token comment">// 归并  </span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 根据mid和right进行判断  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">else</span><span class="token punctuation">{</span>  
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 指针未到最后的剩余序列直接接在后面  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 重要，将tmp已排好序的元素按照位置拷贝到原数组中  </span>
    k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 初始化临时变量  </span>
    <span class="token comment">// 重要，加上判断条件  </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">// 原数组left到right的值重排  </span>
        nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>时间复杂度：O(nlogn), 空间复杂度：O(n)，属于稳定排序</p> <h3 id="_8-桶排序"><a href="#_8-桶排序" class="header-anchor">#</a> 8. 桶排序</h3> <h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <h3 id="_1-反转链表"><a href="#_1-反转链表" class="header-anchor">#</a> 1. 反转链表</h3> <p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br> <strong>方法一：迭代</strong><br>
使用辅助结点，遍历链表，反转每个指针指向。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**  
 * Definition for singly-linked list.  
 * public class ListNode {  
 *     int val;  
 *     ListNode next;  
 *     ListNode(int x) { val = x; }  
 * }  
 */</span>  
<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> head<span class="token punctuation">;</span>  
        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token class-name">ListNode</span> next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            next <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>  
            pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>  
            cur <span class="token operator">=</span> next<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> pre<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p><strong>方法二：递归</strong><br>
从第一个结点head开始看，第二个结点为head.next，如果要反转第一个结点和第二个结点之间的指针，则我们使用<code>head.next.next = head</code>让第二个结点指针指向第一个结点，然后设置<code>head.next=null</code>，即断开指向第二个结点的指针。这样我们就完成了第一个指针的反转，但是这样带来了一个问题，那就是第三个结点丢失了，发生错误。那么，怎么解决呢？如果我们从最后一个结点开始这样操作，那不就行了。所以我们使用尾递归，就是从尾巴处开始操作，前面的结点依次入栈，然后从最后一个结点开始执行上述操作即可。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">// 递归终止条件  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> head<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">return</span> head<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 尾递归，将结点依次入栈  </span>
        <span class="token class-name">ListNode</span> cur <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">// 从最后一个结点开始，反转指针  </span>
        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>  
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  

        <span class="token keyword">return</span> cur<span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_2-链表中倒数第k个节点"><a href="#_2-链表中倒数第k个节点" class="header-anchor">#</a> 2. 链表中倒数第k个节点</h3> <p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。<br> <strong>方法：双指针</strong><br>
使用快慢指针进行遍历，快指针比慢指针快n个结点，然后快慢指针同时开始前进，当快指针走到链表尾部时，慢指针刚好走到倒数第k个结点，然后注意题目中的定义进行细节调试即可。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">ListNode</span> <span class="token function">getKthFromEnd</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token class-name">ListNode</span> p <span class="token operator">=</span> head<span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            k<span class="token operator">--</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            head <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  

        <span class="token keyword">return</span> head<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_3-回文链表"><a href="#_3-回文链表" class="header-anchor">#</a> 3. 回文链表</h3> <p>请判断一个链表是否为回文链表。<br>
输入: 1-&gt;2-&gt;2-&gt;1<br>
输出: true<br>
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？<br> <strong>方法：快慢指针+反转链表+奇偶情况</strong><br>
首先使用快慢指针找到链表的中点，在快慢指针遍历的过程中，反转中点前面的链表。<br>
找到中点后，需要判断中点是奇数中点还是偶数中点，根据快指针fast的值进行判断，然后调整指针。使接下来要遍历的指针置于中点两侧。<br>
一边向左，一边向右遍历链表并比较数值。最终时间复杂度为O(n)，空间复杂度为O(1)。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token class-name">ListNode</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        
        <span class="token class-name">ListNode</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 注意快指针初始指向，画图理解  </span>
        <span class="token class-name">ListNode</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>  
        <span class="token class-name">ListNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token comment">// 找到中点并反转前部链表  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            <span class="token class-name">ListNode</span> next <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            slow<span class="token punctuation">.</span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span>  
            pre <span class="token operator">=</span> slow<span class="token punctuation">;</span>  
            slow <span class="token operator">=</span> next<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 以上循环后，slow在中点位置，pre在中点前一个位置  </span>
        <span class="token comment">// 若fast为空表示长度为偶数，否则为奇数  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 遍历比较中点两侧的值  </span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">.</span>val <span class="token operator">!=</span> slow<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h2 id="dfs-deep-first-search"><a href="#dfs-deep-first-search" class="header-anchor">#</a> DFS(Deep First Search)</h2> <h2 id="bfs-breath-first-search"><a href="#bfs-breath-first-search" class="header-anchor">#</a> BFS(Breath First Search)</h2> <h2 id="递归"><a href="#递归" class="header-anchor">#</a> 递归</h2> <p>递归，即在函数执行过程中，调用自身完成相关操作的过程。<br>
每次调用到自身时，要记得这时不再执行下一行代码了，要先传入一个新的参数重新执行，相当于跳入一个新的执行栈。当递归执行到最后，通过返回值或者其他表达式得到结果，返回之前的执行栈，然后执行完递归调用的下面代码，再次返回，直至回到第一次执行结束。自顶向下递，自底向上归。</p> <h3 id="递归的三大要素"><a href="#递归的三大要素" class="header-anchor">#</a> 递归的三大要素</h3> <ol><li>明确函数的功能<br>
从宏观上把控函数的功能，不去深入递归过程，明确定义的函数要做什么。比如计算 n 的阶乘等。</li> <li>寻找递归终止条件<br>
递归在调用函数的过程中，要知道我们传入的参数满足什么条件时，递归结束，然后再返回结果，寻找终止条件。比如当递归到某一项，可以知道这一项结果是什么，则将递归次数就设置为该项。或者如二叉树向下递归，当递归到结点为空时，就返回，结点为空即为递归终止条件。</li> <li>缩小问题规模，找出函数的等价关系式<br>
根据题目要求找出这一层递归与下一层递归之间的关系，可能是赋值，可能是相减，可能是无返回值只实现相应功能，多多刷题。</li></ol> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <h3 id="_1-二叉树的前序遍历"><a href="#_1-二叉树的前序遍历" class="header-anchor">#</a> 1. 二叉树的前序遍历</h3> <h3 id="_2-二叉树的中序遍历"><a href="#_2-二叉树的中序遍历" class="header-anchor">#</a> 2. 二叉树的中序遍历</h3> <h3 id="_3-二叉树的后序遍历"><a href="#_3-二叉树的后序遍历" class="header-anchor">#</a> 3. 二叉树的后序遍历</h3> <h3 id="_4-二叉树的层序遍历"><a href="#_4-二叉树的层序遍历" class="header-anchor">#</a> 4. 二叉树的层序遍历</h3> <p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。<br> <strong>方法：队列</strong><br>
使用队列存储每个结点，然后将出队访问的结点值添加到列表，并将该结点的左右子树依次入队，直至为空。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">// 使用LinkdedList模拟队列操作  </span>
        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token comment">// remove从头部出来  </span>
            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">// 将左右子树入队  </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 转换成数组，这样更耗时，可以直接使用数组赋值  </span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token operator">::</span><span class="token function">valueOf</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_5-二叉树的深度"><a href="#_5-二叉树的深度" class="header-anchor">#</a> 5. 二叉树的深度</h3> <p><strong>方法：递归</strong><br>
求二叉树的深度，就要求左右子树的最大深度，因此遍历左右子树，递归一次深度+1，最终得到结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_6-平衡二叉树"><a href="#_6-平衡二叉树" class="header-anchor">#</a> 6. 平衡二叉树</h3> <p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。<br> <strong>方法：递归</strong><br>
首先，判断根节点是不是平衡的，那么需要判断根结点的左子树的深度和右子树的深度，于是独立出一个求深度的函数。<br>
当根节点平衡时，递归判断根结点的左子树是否平衡，右子树是否平衡，返回相应结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">// root为空表示递归到了底部  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">-</span><span class="token function">height</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 二叉树的深度  </span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">height</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">return</span> node <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">height</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_7-二叉排序树（查找树、搜索树）"><a href="#_7-二叉排序树（查找树、搜索树）" class="header-anchor">#</a> 7. 二叉排序树（查找树、搜索树）</h3> <h3 id="_8-完全二叉树"><a href="#_8-完全二叉树" class="header-anchor">#</a> 8. 完全二叉树</h3> <h3 id="_9-根据二叉树前序和中序，建立二叉树"><a href="#_9-根据二叉树前序和中序，建立二叉树" class="header-anchor">#</a> 9. 根据二叉树前序和中序，建立二叉树</h3> <p>例如：<br>
前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]<br> <strong>方法一: 递归</strong><br>
从前序遍历中找到树的根以及左右子树的根，然后根据根在中序遍历的索引位置，得到左右子树区间，递归构造二叉树。<br>
（1）使用HashMap存储中序遍历中的值与对应的索引值<br>
（2）前序遍历的左边界值即为根，然后找到根在中序遍历中的位置<br>
（3）递归构建左右子树，找到左右子树的根和对应的区间</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 使用全局遍历方便传递参数  </span>
    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre<span class="token punctuation">;</span>  
    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">buildTree</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre1order<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> inorder<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token keyword">this</span><span class="token punctuation">.</span>pre <span class="token operator">=</span> preorder<span class="token punctuation">;</span>  <span class="token comment">// 全局变量赋值  </span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> inorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> pre<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token comment">// 需要传入的变量为前序的对应左右区间和中序的对应左右区间  </span>
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token keyword">int</span> pleft<span class="token punctuation">,</span> <span class="token keyword">int</span> pright<span class="token punctuation">,</span> <span class="token keyword">int</span> ileft<span class="token punctuation">,</span> <span class="token keyword">int</span> iright<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">// 当左区间大于右区间时，返回null  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>pleft <span class="token operator">&gt;</span> pright <span class="token operator">||</span> ileft <span class="token operator">&gt;</span> iright<span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  

        <span class="token comment">// 从前序中左边界找到根，然后找到其在中序中对应的位置  </span>
        <span class="token class-name">TreeNode</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>pleft<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">int</span> p <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  

        <span class="token comment">// 递归构造，需要画图理解左右区间取值  </span>
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>pleft<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pleft<span class="token operator">+</span>p<span class="token operator">-</span>ileft<span class="token punctuation">,</span> ileft<span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">helper</span><span class="token punctuation">(</span>pleft<span class="token operator">+</span>p<span class="token operator">-</span>ileft<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> pright<span class="token punctuation">,</span> p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> iright<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_10-树的子结构"><a href="#_10-树的子结构" class="header-anchor">#</a> 10. 树的子结构</h3> <p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>
B是A的子结构， 即 A中有出现和B相同的结构和节点值。<br>
例如:<br>
输入：A = [3,4,5,1,2], B = [4,1]<br>
输出：true<br> <strong>递归</strong><br>
B是A的子结构，假设C是A的一颗子树，满足以下条件：<br>
B的值与C相等，B的左子树值与右子树值跟C的左右子树值对应相等（递归判断）<br>
那么，C在哪？C从A的根节点开始寻找，如果不是再分别到A的左子树和右子树中寻找，这样又形成了一个递归。<br>
处理边界条件：<br>
首先A和B有一个为空树时，返回false<br>
然后找到B的某一子树为空时，则返回true（说明之前的都满足条件）<br>
如果找到A的某一字树为空时，则返回false（这时B还没找完，说明不是子结构）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**  
* Binary TreeNode  
public class TreeNode{  
    int val;  
    TreeNode left;  
    TreeNode right;  
    TreeNode(int x){ val = x; }  
}  
*/</span>  
<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token class-name">B</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token comment">// 从A开始寻找，判断A和B， 然后再从A的子树寻找，或的关系  </span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubTree</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">isSubTree</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> <span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> <span class="token class-name">B</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">// 注意条件顺序不能错，先判断B是否为空  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">B</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">A</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token comment">// 判断子树是否满足条件  </span>
        <span class="token keyword">return</span> <span class="token class-name">A</span><span class="token punctuation">.</span>val <span class="token operator">==</span> <span class="token class-name">B</span><span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span> <span class="token class-name">B</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  

</code></pre></div><h3 id="_11-二叉树的镜像"><a href="#_11-二叉树的镜像" class="header-anchor">#</a> 11. 二叉树的镜像</h3> <p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。<br> <strong>方法一：递归</strong><br>
首先是递归终止条件：当前结点为空时，返回null<br>
然后递归过程：根的左子树和右子树进行交换，然后递归左右子树进行该操作</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token comment">// 左右子树交换  </span>
        <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  
        root<span class="token punctuation">.</span>left <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>  
        root<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>  
        
        <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token function">mirrorTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p><strong>方法二：栈</strong><br>
将根节点入栈，当栈不为空时，交换栈顶元素的左右子树，然后入栈的顺序是先右子树后左子树，即可实现二叉树的翻转。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token class-name">TreeNode</span> node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token comment">// 交换左右子树  </span>
            <span class="token class-name">TreeNode</span> tmp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>  
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>  
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  
            <span class="token comment">// 先右后左  </span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  
            <span class="token punctuation">}</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_12-对称的二叉树"><a href="#_12-对称的二叉树" class="header-anchor">#</a> 12. 对称的二叉树</h3> <p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。<br> <strong>方法：递归</strong><br>
判断一棵树是否对称，那么首先看根节点的左右子树：<br>
左右子树都为空，对称<br>
左右子树有一颗为空，不对称<br>
左子树和右子树值不相等，不对称<br>
以上即为递归的终止条件，那么如果左右子树满足了上述条件，接下来就要判断左子树的左孩子和右子树的右孩子，以及左子树的右孩子和右子树的左孩子是否满足上述条件，构成递归。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSymmetric</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token comment">// 直接传递左右子树进行判断，比较方便  </span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">// 判断递归终止条件  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  
        <span class="token comment">// 递归调用  </span>
        <span class="token keyword">return</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">helper</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_13-二叉搜索树中的第k大结点"><a href="#_13-二叉搜索树中的第k大结点" class="header-anchor">#</a> 13. 二叉搜索树中的第k大结点</h3> <p><strong>方法：遍历存值</strong><br>
二叉搜索树的中序遍历是从小到大排序的，中序遍历顺序为左根右，如果从大到小排序，则遍历的顺序则为右根左。所以在一个递归中进行该遍历，要求第k大，则直接使用一个全局遍历存储递归次数，再用一个变量存储结果，当其等于k时，停止遍历，返回结果。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token comment">// 设置全局变量  </span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    使用<span class="token keyword">void</span>声明函数  
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">helper</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>  
        <span class="token comment">// 单独判断左右子树再递归  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">++</span>count <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>  
            res <span class="token operator">=</span> root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>  
            <span class="token keyword">return</span><span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_14-二叉搜索树的最近公共祖先"><a href="#_14-二叉搜索树的最近公共祖先" class="header-anchor">#</a> 14. 二叉搜索树的最近公共祖先</h3> <p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br> <strong>方法：递归</strong><br>
二叉搜索树的每个结点都不相等，对于p、q，有以下三种可能：<br>
p、q都小于根结点，在左子树<br>
p、q都大于根节点，在右子树<br>
p、q一个在左子树，一个在右子树，那么公共祖先为根节点</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> q<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h3 id="_15-二叉树的最近公共祖先"><a href="#_15-二叉树的最近公共祖先" class="header-anchor">#</a> 15. 二叉树的最近公共祖先</h3> <p>最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br> <strong>方法：递归</strong><br>
本题中各结点的值都不相等，结果仍然有三种可能：<br>
p、q都在左子树<br>
p、q都在右子树<br>
p、q一左一右<br>
知道这几种情况该如何形成递归？首先是递归终止条件：当前结点为空时，返回null，另外当p和q有一个跟当前结点值相等时，则返回当前结点。<br>
然后由上而下递归，分别取左子树、p、q和右子树、p、q递归。递归完成后，当左右两个值都不为空，说明左子树和右子树分别有值与p或者q相等，因此说明p和q分开在左右子树，公共祖先为根结点。然后当左结果不为空时，说明p、q都在左子树中，返回左子树当前结点。当右结果不为空时，说明p、q都在右子树中，返回右子树递归的结点。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  
    <span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> p<span class="token punctuation">,</span> <span class="token class-name">TreeNode</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val <span class="token operator">||</span> q<span class="token punctuation">.</span>val <span class="token operator">==</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  
            <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
        <span class="token comment">// 递归左右子树  </span>
        <span class="token class-name">TreeNode</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token class-name">TreeNode</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token comment">// 说明p、q分列在左右子树，返回根结点  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>  
            <span class="token keyword">return</span> root<span class="token punctuation">;</span>  
        <span class="token comment">// left不空，返回左子树递归的结点+  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">return</span> left<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// right不空，返回右子树递归的结点  </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
            <span class="token keyword">return</span> right<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span>  
        <span class="token comment">// 否则返回空  </span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><h2 id="动态规划"><a href="#动态规划" class="header-anchor">#</a> 动态规划</h2></div> <footer class="page-edit" style="display:none;"><!----> <!----></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/myBlog/assets/js/app.e2a5d604.js" defer></script><script src="/myBlog/assets/js/3.8a7523f6.js" defer></script><script src="/myBlog/assets/js/1.015dc369.js" defer></script><script src="/myBlog/assets/js/22.aff7fda6.js" defer></script>
  </body>
</html>
