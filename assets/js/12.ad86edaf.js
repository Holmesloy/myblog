(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{494:function(_,v,t){_.exports=t.p+"assets/img/dns.1c33fac0.png"},495:function(_,v,t){_.exports=t.p+"assets/img/dns1.0e8d3473.png"},496:function(_,v,t){_.exports=t.p+"assets/img/tcp1.d6e8cbde.png"},497:function(_,v,t){_.exports=t.p+"assets/img/tcp2.6cb4769c.png"},552:function(_,v,t){"use strict";t.r(v);var r=t(4),s=Object(r.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h2",{attrs:{id:"主体流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主体流程"}},[_._v("#")]),_._v(" 主体流程")]),_._v(" "),r("ul",[r("li",[_._v("DNS解析（域名转化为ip地址）")]),_._v(" "),r("li",[_._v("TCP连接（三次握手）")]),_._v(" "),r("li",[_._v("浏览器发送http请求")]),_._v(" "),r("li",[_._v("服务器处理请求")]),_._v(" "),r("li",[_._v("浏览器解析并渲染页面")]),_._v(" "),r("li",[_._v("断开连接（四次挥手）")])]),_._v(" "),r("h2",{attrs:{id:"dns解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[_._v("#")]),_._v(" DNS解析")]),_._v(" "),r("p",[_._v("在DNS解析前，浏览器会首先进行url合法性和安全性检查，然后去查找缓存（这里可以扩展缓存知识）。"),r("br"),_._v("\nDNS解析：域名转化为ip地址"),r("br"),_._v(" "),r("strong",[_._v("DNS缓存查找顺序：")]),r("br"),_._v(" "),r("img",{attrs:{src:t(494),alt:"dns1"}}),r("br"),_._v(" "),r("strong",[_._v("DNS域名解析过程")]),r("br"),_._v(" "),r("img",{attrs:{src:t(495),alt:"dns"}}),r("br"),_._v(" "),r("strong",[_._v("网址解析过程")])]),_._v(" "),r("ul",[r("li",[_._v("高级域名到低级域名：. -> .com -> google.com. -> www.google.com.")])]),_._v(" "),r("p",[r("strong",[_._v("DNS负载均衡技术")]),r("br"),_._v("\n在DNS服务器中，为一个主机名配置多个ip地址，按需返回不同的解析结果，使不同的客户端访问不同的服务器。"),r("br"),_._v("\n扩展：DNS解析过程中，还可能会发生DNS劫持问题，然后还有前端的dns-prefetch优化。")]),_._v(" "),r("h2",{attrs:{id:"建立tcp连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#建立tcp连接"}},[_._v("#")]),_._v(" 建立TCP连接")]),_._v(" "),r("h3",{attrs:{id:"三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),r("img",{staticStyle:{zoom:"36%"},attrs:{src:t(496)}}),_._v(" "),r("p",[_._v("SYN（Synchronize Sequence Numbers）：同步序列编号"),r("br"),_._v("\nACK（Acknowledge character）：确认字符")]),_._v(" "),r("p",[r("strong",[_._v("过程：")])]),_._v(" "),r("ol",[r("li",[_._v("客户端给服务器发送一个SYN报文，并确定初始化序列号seq=x，此时SYN=1，报文段不能携带数据")]),_._v(" "),r("li",[_._v("服务器返回确认SYN报文，SYN=1，并缺点初始化序列号seq=y，并返回确认帧ACK=1，ACK确认号的值ack=x+1")]),_._v(" "),r("li",[_._v("客户端收到后返回确认帧ACK=1，确认号ack=y+1，序列号seq=x+1，此时ACK报文段可以携带数据，数据会消耗序号")])]),_._v(" "),r("p",[r("strong",[_._v("1. 为什么需要三次握手，两次不行吗？")])]),_._v(" "),r("ul",[r("li",[_._v("三次握手的目的是确认双方的接收与发送能力都正常。")]),_._v(" "),r("li",[_._v("第三次为了防止已经失效的连接请求到达服务端，让服务器错误打开连接。")]),_._v(" "),r("li",[_._v("如果只是两次握手就建立连接的话，若客户端之前发送的一些失效请求又到达了服务端，那么服务器就会发送确认，直接建立连接，然后等待客户端发送数据，实际上这时候客户端并没有要发送数据，浪费了资源。")])]),_._v(" "),r("p",[r("strong",[_._v("2. SYN-ACK重传次数")]),r("br"),_._v("\n服务器发送回SYN-ACK包，若未收到客户端确认包，则服务器进行重传，每次重传间隔时间一般是指数增长。"),r("br"),_._v("\n若超过最大重传次数，则系统将该连接信息从半连接队列中删除。")]),_._v(" "),r("p",[r("strong",[_._v("3. ISN（Initial Sequence Number）是固定的吗？")]),r("br"),_._v("\n客户端和服务端需要交换ISN，因为接收数据时要按照序列号组装数据，保证可靠传输。如果ISN固定，则攻击者容易猜出后序的确认号，因此ISN是动态生成的。")]),_._v(" "),r("p",[r("strong",[_._v("4. 三次握手过程中可以携带数据吗?")])]),_._v(" "),r("ul",[r("li",[_._v("第三次握手可以携带数据，第一次、第二次不可以。")]),_._v(" "),r("li",[_._v("如果第一次可以携带数据，那么服务器会比较容易受到恶意攻击，攻击者会发送很多数据给服务器，造成服务器响应缓慢。")]),_._v(" "),r("li",[_._v("第三次握手客户端已经知道服务器的接收和发送能力，因此可以携带数据。")])]),_._v(" "),r("p",[r("strong",[_._v("5. SYN洪泛攻击")]),r("br"),_._v("\n一种典型的Dos/DDos攻击：")]),_._v(" "),r("ul",[r("li",[_._v("服务器端资源是在第二次握手时分配，客户端资源是三次握手时分配，因此服务器容易受到SYN攻击")]),_._v(" "),r("li",[_._v("客户端短时间内伪造大量不存在IP地址，向服务器不断发送SYN包，服务器发送回复但接收不到确认包，因此不断重发至超时")]),_._v(" "),r("li",[_._v("伪造SYN包长时间占用队列，使正常SYN包被丢弃，使网络阻塞甚至瘫痪")])]),_._v(" "),r("p",[r("strong",[_._v("防御SYN攻击的方法：")])]),_._v(" "),r("ul",[r("li",[_._v("缩短超时（SYN Timeout）时间")]),_._v(" "),r("li",[_._v("增加最大半连接数")]),_._v(" "),r("li",[_._v("过滤网关防护")])]),_._v(" "),r("p",[r("strong",[_._v("6. 第三次握手失败怎么办？")]),r("br"),_._v("\n服务器不会重传ack报文，而是发送RST报文段，进入CLOSED状态，防止SYN洪泛攻击。")]),_._v(" "),r("p",[r("strong",[_._v("总结")])]),_._v(" "),r("ul",[r("li",[_._v("三次握手建立连接的主要目的是同步序列号，保证可靠传输。")]),_._v(" "),r("li",[_._v("TCP很多特性如流量控制、消息重发等依赖于序列号")]),_._v(" "),r("li",[_._v("因此，三次握手中的报文被称为SYN")])]),_._v(" "),r("h2",{attrs:{id:"发送http请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求"}},[_._v("#")]),_._v(" 发送HTTP请求")]),_._v(" "),r("p",[_._v("客户端向服务器发送HTTP请求（应用层），请求信息包括："),r("br"),_._v("\n请求头（Request Header）：请求方法、目标地址、遵循协议等"),r("br"),_._v("\n请求主体（其他参数）"),r("br"),_._v("\n注：可以扩充http字段知识")]),_._v(" "),r("h2",{attrs:{id:"服务器处理请求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求"}},[_._v("#")]),_._v(" 服务器处理请求")]),_._v(" "),r("p",[_._v("HTTP响应报文由以下部分构成："),r("br"),_._v("\n状态行"),r("br"),_._v("\n响应头（Response Header）"),r("br"),_._v("\n响应正文")]),_._v(" "),r("h2",{attrs:{id:"浏览器解析并渲染页面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析并渲染页面"}},[_._v("#")]),_._v(" 浏览器解析并渲染页面")]),_._v(" "),r("p",[_._v("整体过程："),r("br"),_._v("\n构建DOM树 -> 构建CSSOM树 -> 构建render树 -> 绘制render树"),r("br"),_._v("\n详细过程如下：")]),_._v(" "),r("ul",[r("li",[_._v("解析HTML形成DOM树")]),_._v(" "),r("li",[_._v("解析CSS形成CSSOM（CSS规则）树")]),_._v(" "),r("li",[_._v("合并DOM树和CSSOM树形成布局树（Layout Tree）")]),_._v(" "),r("li",[_._v("渲染并绘制页面")])]),_._v(" "),r("p",[r("strong",[_._v("页面绘制过程：")])]),_._v(" "),r("ul",[r("li",[_._v("回流：当页面中的一部分（或全部）因为元素的规模尺寸、布局，隐藏等属性改变而需要重新构建（也可以称为重布局或者重排）。每个页面至少产生一次回流，即第一次加载时。")]),_._v(" "),r("li",[_._v("重绘：当页面中的一些元素需要更新属性，而这些属性只影响元素的外观，诸如背景颜色、文字颜色等，而不会影响布局时，页面的更新就叫做重绘。")]),_._v(" "),r("li",[_._v("因此，回流一定会发生重绘，重绘不一定会发生回流。")])]),_._v(" "),r("p",[r("strong",[_._v("针对回流和重绘的优化")]),r("br"),_._v("\nCSS：")]),_._v(" "),r("ul",[r("li",[_._v("避免使用table布局")]),_._v(" "),r("li",[_._v("尽量在DOM树的最末端改变class")]),_._v(" "),r("li",[_._v("避免设置多层内联样式")]),_._v(" "),r("li",[_._v("将动画效果应用到position属性为absolute或fixed的元素上")])]),_._v(" "),r("p",[_._v("Javascript：")]),_._v(" "),r("ul",[r("li",[_._v("避免频繁操作样式，可以将样式写在class中然后统一改写class")]),_._v(" "),r("li",[_._v("避免频繁操作DOM，可以创建一个documentFragment，在其中书写DOM操作，最后添加到文档中")]),_._v(" "),r("li",[_._v("也可以先将元素设置display:none，操作结束后再显示，none元素上进行DOM操作不会引发回流和重绘")])]),_._v(" "),r("p",[_._v("扩展："),r("br"),_._v("\n为什么CSS放在head中，js放在body最后？"),r("br"),_._v("\n因为js会阻塞DOM渲染，为了用户体验需要优先加载显示页面。")]),_._v(" "),r("h2",{attrs:{id:"断开连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#断开连接"}},[_._v("#")]),_._v(" 断开连接")]),_._v(" "),r("p",[_._v("现在的页面为了优化请求耗时，默认都会开启持久连接，所以TCP连接断开的时间一般是这个tab页关闭时。")]),_._v(" "),r("h3",{attrs:{id:"四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),r("img",{staticStyle:{zoom:"80%"},attrs:{src:t(497)}}),_._v(" "),r("p",[_._v("TCP半关闭：连接端在结束数据发送后还能接收另一端的数据。"),r("br"),_._v("\n客户端或服务器均可发起主动挥手过程。")]),_._v(" "),r("p",[r("strong",[_._v("过程：")]),r("br"),_._v("\n（1）主机A数据发送完毕时，向主机B发送带有FIN标记的报文段，FIN=1，序列号seq=u"),r("br"),_._v("\n（2）主机B收到后，向主机A发送一个确认序号ACK，ACK=1,ack=u+1,序列号seq=v（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）"),r("br"),_._v("\n（3）主机B应用程序处理完请求后，向主机A发送FIN报文段，FIN=1，ACK=1，seq=w，ack=u+1。"),r("br"),_._v("\n（4）主机A受到FIN报文段后，向主机B发送一个ACK表示连接彻底释放，ACK=1，seq=u+1，ack=w+1。"),r("br"),_._v("\n注意：如果是客户端收到连接释放报文段，则发送完确认报文段后主动关闭并进入TIME_WAIT状态，等待设置的计时器时间2MSL后，再进入CLOSED状态。"),r("br"),_._v("\n整个过程中，主机A首先停止发送，然后主机B发送完成之后也停止发送，两者断开。"),r("br"),_._v(" "),r("strong",[_._v("1. 为什么需要四次挥手？")])]),_._v(" "),r("ul",[r("li",[_._v("TCP是全双工通信，断开时需要确定客户端和服务器都不再发送数据")]),_._v(" "),r("li",[_._v("另外，服务端收到连接断开请求后，可能其中程序还没有处理完请求响应，所以先发送一个ACK告诉客户端“你发的FIN报文段我收到了”。等到程序处理完之后，服务端再发送一个FIN报文段，我发送完成了，可以断开了，所以需要四次挥手。")])]),_._v(" "),r("p",[r("strong",[_._v("2. 2MSL等待状态")])]),_._v(" "),r("ul",[r("li",[_._v("TIME_WAIT状态也称为2MSL等待状态。MSL表示TCP报文段最大生存时间。")]),_._v(" "),r("li",[_._v("当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留时间为2倍的MSL。若服务器没收到该ACK，则会超时重传FIN-ACK，然后客户端再次发送ACK，保证服务器能够收到。")]),_._v(" "),r("li",[_._v("还可以防止已失效的连接请求报文段出现再本连接中，因为经过2MSL，本连接的所有报文段会从网络上消失，不影响下一个新的连接。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);